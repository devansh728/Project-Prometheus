"""
SentinEV - Safety Agent
Handles minor issues that can be resolved by user behavior change.
Uses RAG for precautions and Gemini for natural language advice.
"""

import os
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field

# Google Gemini
try:
    import google.generativeai as genai

    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False


@dataclass
class SafetyAdvice:
    """Safety advice generated by the agent."""

    prediction_id: str
    component: str
    issue_type: str
    severity: str
    days_to_failure: int
    tips: List[str]
    rag_sources: List[str]
    gemini_message: str
    points_awarded: int
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


class SafetyAgent:
    """
    Safety Agent for handling minor issues.

    Triggered when:
    - User ACCEPTS a prediction warning
    - Issue can be resolved by behavior change
    - No immediate component damage

    Actions:
    1. Query RAG for precautions
    2. Generate advice using Gemini
    3. Award positive points
    4. Monitor for improvement
    """

    # Precaution templates by anomaly type
    PRECAUTION_TEMPLATES = {
        "thermal_battery": [
            "Avoid fast charging when battery is already warm",
            "Park in shade during hot weather",
            "Precondition battery before high-power driving",
            "Reduce aggressive acceleration to lower heat generation",
        ],
        "thermal_motor": [
            "Reduce sustained high-speed driving",
            "Allow cooling periods during long highway trips",
            "Avoid repeated hard accelerations",
            "Check cooling system fluid levels",
        ],
        "thermal_brake": [
            "Use regenerative braking more to reduce friction brake load",
            "Downshift or use regen on downhill sections",
            "Allow brakes to cool after sustained use",
            "Avoid riding the brakes",
        ],
        "driving_behavior": [
            "Accelerate smoothly from stops",
            "Anticipate traffic to brake gently",
            "Maintain steady speeds on highway",
            "Use cruise control when possible",
        ],
        "power_anomaly": [
            "Check tire pressure for optimal efficiency",
            "Reduce accessory loads (AC, heating)",
            "Drive at moderate speeds for better regen",
            "Ensure proper battery conditioning",
        ],
        "wear_degradation": [
            "Rotate tires regularly",
            "Check brake pad thickness",
            "Monitor suspension components",
            "Schedule preventive maintenance",
        ],
    }

    # Points awarded for accepting warnings
    ACCEPTANCE_POINTS = {
        "low": 10,
        "medium": 20,
        "high": 30,
        "critical": 50,
    }

    def __init__(self, knowledge_base=None):
        """Initialize Safety Agent."""
        self.knowledge_base = knowledge_base
        self.llm = None
        self._init_gemini()

    def _init_gemini(self):
        """Initialize Gemini LLM."""
        if not GEMINI_AVAILABLE:
            return

        api_key = os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY")
        if api_key:
            try:
                genai.configure(api_key=api_key)
                self.llm = genai.GenerativeModel("gemini-2.0-flash")
                print("âœ“ Safety Agent Gemini initialized")
            except Exception as e:
                print(f"âš ï¸ Safety Agent Gemini init failed: {e}")

    def _get_rag_precautions(self, anomaly_type: str, component: str) -> List[Dict]:
        """Get precautions from RAG knowledge base."""
        if not self.knowledge_base:
            return []

        try:
            # Search for relevant precautions
            query = f"{component} {anomaly_type} prevention precaution safety"
            results = self.knowledge_base.semantic_search(query, k=3)
            return results
        except Exception as e:
            print(f"RAG search error: {e}")
            return []

    def _generate_gemini_advice(
        self,
        anomaly_type: str,
        component: str,
        days_to_failure: int,
        tips: List[str],
        rag_context: List[Dict],
    ) -> str:
        """Generate personalized advice using Gemini."""
        if not self.llm:
            return f"Consider following these tips to prevent {component} issues."

        # Build context from RAG
        rag_text = ""
        if rag_context:
            rag_text = "\n".join(
                [f"- {r.get('content', '')[:200]}" for r in rag_context[:2]]
            )

        prompt = f"""You are a friendly EV maintenance advisor. The user has accepted a warning about their vehicle.

Issue: {anomaly_type.replace('_', ' ')} affecting {component}
Predicted failure in: {days_to_failure} days
Recommended tips: {', '.join(tips[:3])}

Industry knowledge:
{rag_text}

Generate a brief, encouraging message (2-3 sentences) that:
1. Thanks them for accepting the warning
2. Explains how following the tips will help
3. Mentions the positive impact on their driving score

Keep it friendly and concise."""

        try:
            response = self.llm.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            print(f"Gemini generation error: {e}")
            return f"Thank you for accepting this warning! Following these tips will help prevent {component} issues and boost your driving score."

    def process_accepted_prediction(
        self,
        prediction_id: str,
        anomaly_type: str,
        component: str,
        severity: str,
        days_to_failure: int,
        vehicle_context: Dict[str, Any] = None,
    ) -> SafetyAdvice:
        """
        Process when user accepts a prediction warning.

        Args:
            prediction_id: Unique prediction identifier
            anomaly_type: Type of anomaly detected
            component: Affected component
            severity: Severity level
            days_to_failure: Estimated days until failure
            vehicle_context: Additional vehicle state info

        Returns:
            SafetyAdvice with tips and Gemini message
        """
        # Get template tips
        tips = self.PRECAUTION_TEMPLATES.get(
            anomaly_type, self.PRECAUTION_TEMPLATES["driving_behavior"]
        ).copy()

        # Get RAG precautions
        rag_results = self._get_rag_precautions(anomaly_type, component)
        rag_sources = [
            r.get("metadata", {}).get("fault_id", "unknown") for r in rag_results
        ]

        # Add RAG-based tips if available
        for result in rag_results[:2]:
            content = result.get("content", "")
            if "recommended_action" in content.lower():
                # Extract recommended action from RAG result
                lines = content.split("\n")
                for line in lines:
                    if "recommended" in line.lower() or "action" in line.lower():
                        action = line.split(":")[-1].strip()
                        if action and action not in tips:
                            tips.insert(0, action)
                            break

        # Generate Gemini message
        gemini_message = self._generate_gemini_advice(
            anomaly_type, component, days_to_failure, tips, rag_results
        )

        # Calculate points
        points = self.ACCEPTANCE_POINTS.get(severity, 10)

        return SafetyAdvice(
            prediction_id=prediction_id,
            component=component,
            issue_type=anomaly_type,
            severity=severity,
            days_to_failure=days_to_failure,
            tips=tips[:5],  # Limit to 5 tips
            rag_sources=rag_sources,
            gemini_message=gemini_message,
            points_awarded=points,
        )

    def generate_improvement_message(
        self,
        vehicle_id: str,
        previous_score: int,
        current_score: int,
        improvement_areas: List[str],
    ) -> Dict[str, Any]:
        """
        Generate encouragement message when user shows improvement.

        Args:
            vehicle_id: Vehicle identifier
            previous_score: Score before improvement
            current_score: Current score
            improvement_areas: Areas that improved

        Returns:
            Chatbot message dict
        """
        score_diff = current_score - previous_score

        if score_diff > 0:
            message = (
                f"ğŸŒŸ Great job! Your driving score improved by {score_diff} points! "
            )
            if improvement_areas:
                message += (
                    f"You're doing better with {', '.join(improvement_areas[:2])}."
                )
        else:
            message = "Keep following the safety tips to improve your score!"

        return {
            "type": "safety_update",
            "vehicle_id": vehicle_id,
            "variant": "positive" if score_diff > 0 else "neutral",
            "score_change": score_diff,
            "message": message,
            "timestamp": datetime.now().isoformat(),
        }

    def to_chatbot_message(self, advice: SafetyAdvice) -> Dict[str, Any]:
        """Convert SafetyAdvice to chatbot message format."""
        return {
            "type": "safety_advice",
            "prediction_id": advice.prediction_id,
            "title": f"âœ… Warning Accepted - {advice.component.replace('_', ' ').title()}",
            "message": advice.gemini_message,
            "tips": advice.tips,
            "points_awarded": advice.points_awarded,
            "severity": advice.severity,
            "rag_sources": advice.rag_sources,
            "timestamp": advice.timestamp,
        }


# Singleton instance
_safety_agent = None


def get_safety_agent(knowledge_base=None) -> SafetyAgent:
    """Get or create Safety Agent singleton."""
    global _safety_agent
    if _safety_agent is None:
        _safety_agent = SafetyAgent(knowledge_base)
    elif knowledge_base and _safety_agent.knowledge_base is None:
        _safety_agent.knowledge_base = knowledge_base
    return _safety_agent
